% \section{Overview and Background}
% \label{sec:overviewbackground}

% In this section, we consider background on Multi-Party Computation (MPC) and program analysis.

% \input{cryptoback}

% \input{progback}

% \subsection{Related Work}


\section{Overview of Our Work}
\label{sec:mpcoverview}

Our work aims to create a novel program analysis that improves the performance of loops within the 
context of MPC. We posit that we can leverage classical optimizations for loops from the 
High Performance Computing (HPC) literature. 
%\ana{I'm not sure what you mean with the above sentnences...}\lindsey{yes, that was not good
%is it clearer now?} 
However there are several caveats. 
Classically, HPC optimizations can perform in parallel any two operations as long as there are processors to perform them. In 
MPC this is not the case. Parallelization for MPC works similarly to operations in PHE- operations 
on secret values can only be performed in parallel with other operations of the same type. 
By using classical techniques a program loop can be segmented to take advantage of this, 
and the overall running time can be greatly reduced. 

In summary, our analysis takes a loop, written using high-level C-like sytnax, and transforms it into 
into a straight-line vectorized MPC target code. We specify the input syntax and the MPC target syntax shortly.
Consider the example shown in \figref{fig:squarearray}: in this
code every member of an array is squared, this takes $n$ operations where $n$ is the size of the array $A$.
In MPC  this can be optimized as shown in \figref{fig:squarearraympc}, each operation can be put in a single
"thread" and can be performed in approximate constant 
time regardless of the number of operations being performed. This is only achievable on operations done
on secret values (in this case MPC shares of values). This is further expanded on in 
\secref{sec:hpcparallelization} and \secref{sec:mpcamortization}.

\begin{figure}[h]
\centering
\begin{minipage}{0.7\textwidth}
% \begin{figure}[h]
\begin{code}
int sq\_arr(int A[]) {
    for(int i = 0; i < A.length; i++) {
        A[i] = A[i] * A[i];
    }
    return A;
}
\end{code}
% \end{figure}
\end{minipage}
\caption{Code to square each member of an array.}
\label{fig:squarearray}
\end{figure}

\begin{figure}[h]
\centering
\begin{minipage}{0.7\textwidth}
% \begin{figure}[h]
\begin{code}
int sq\_arr(Share A[]) {
    B = MUL\_N(A, A);
    return B;
}
\end{code}
% \end{figure}
\end{minipage}
\caption{Simple MPC transformation to square an array.}
\label{fig:squarearraympc}
\end{figure}



% \ana{Yes, I agree with the structure you have. Start with an Overview, then Crypto primitives, particularly MPC, then Program Analysis.}
% \ana{I agree with the general subsections you've outlined too.}
