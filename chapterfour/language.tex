\section{Language Specification}
\label{sec:language}

We start with an IMP-like \cite{Nipkow2014} language, syntactically similar to imperative
C-style languages (C, C++, Java, C\#, etc.). %\ana{What's this ref to?}\lindsey{my mistake, to nothing removed.} 
We restrict our language by disallowing recursion, and assuming that all loop bounds are both known and static. 
% This leaves us with a general language syntax as shown in \figref{fig:impsyntax}.
Next the program is converted to SSA using a modified version of the algorithms of 
Cytron et al. \cite{Cytron1991}. Those algorithms have two main steps: the creation
of $\phi()$ functions at merge points in the program, and the renaming of variables
to ensure that every variable is only on the left hand side of an assignment statement once.
Crucially during our transformation merges between two blocks that contain different variable
versions are not transformed into $\phi()$ nodes but are instead converted to MUX gates. This
prevents data leakage due to observations of program execution. Once in this form loop 
bodies can be unrolled, allowing the MPC compiler to create a circuit 
representation of the program. Our language is similar to recent work
in the MPC literature that optimizes protocol selection during 
compilation \cite{Ishaq2019}. \figref{fig:muximpsyntax} shows our output syntax. 
We assume standard scalar variables (i.e. $\x$, $\y$, ${\sf c}$) and array members (i.e. ${\A[i]}$) are sensitive 
values, while looping variables and variables that represent loop bounds (i.e. $N$, $i$) are known at compile time.
All functions in our language can be vectorized. This means that any function in our language 
(i.e. ADD) can be computed on two arrays for the same cost as computing the same 
function of two scalar values.
%\ana{This last sentence is unclear, try to rewrite.}
%\lindsey{better?}
% However, as stated above, do not include $\phi()$ functions directly 
% and convert if statements to MUX nodes.


% \begin{figure}
% \small
% \[
% \begin{array}{l@{~~~~~}l}
%   \begin{array}{l@{~}l@{~~~}l}
%   s & ::= s ; s \\ 
%   & \mid \x = \y  \\
%   & \mid \x=\y \; \op \; \z \\
%   & \mid {\sf A}[i] = \x \\
%   & \mid \x = \A[i] \\
%   & \mid {\sf for} \; (i = 0; i \le n; \mathit{i\!+\!+}) \; \{ \; s \; \} \\
%   & \mid {\sf if} \; (\x \; \cop \; \y) \; \{ \; s \; \} \; {\sf else} \; \{ \; s \; \} \; & \mathit{statement} \\ 
%   \op &::= + \mid - \mid * \mid / & \mathit{arithmetic} \; \mathit{operator} \\
%   \cop &::=  \; == \; \mid \; != \; \mid \; < \; \mid \; \le & \mathit{comparison} \; \mathit{operator}

%   \end{array}
% \end{array}
% \]
% %\vspace{-0.2in}
% \caption{Source IMP syntax as defined in \cite{Nipkow2014}: \sss is a sequence of statements. 
% \x, \y, \z, \iii, and \nnn are variables.} 
% \label{fig:impsyntax}
% \end{figure}

\begin{figure}
\small
\[
\begin{array}{l@{~~~~~}l}
  \begin{array}{l@{~}l@{~~~}l}
  s & ::= s ; s \\ 
  & \mid \x = \y  \mid \x = p \mid \A[i] = \x \mid \x = \A[i] \\
  & \mid \A[f(i)] = \x \; \mid \x = \A[f(i)] 
  \end{array}
\end{array}
\begin{array}{l@{~~~~~}l}
  \begin{array}{l@{~}l@{~~~}l}  
  p &  ::= {\sf ADD(x, y) \mid ADD\_N(X, Y, n)} & \mathit{primitive} \\ 
  & \mid {\sf SUB(x, y) \mid SUB\_N(X, Y, n)} &  \\ 
  & \mid {\sf MUL(x, y) \mid MUL\_N(X, Y, n)} &  \\ 
  & \mid {\sf CMP(x, y) \mid CMP\_N(X, Y, n)} &  \\ 
  & \mid {\sf XOR(x, y) \mid XOR\_N(X, Y, n)} &  \\ 
  & \mid {\sf SHL(x, y) \mid SHL\_N(X, Y, n)} &  \\ 
  & \mid {\sf SHR(x, y) \mid SHR\_N(X, Y, n)} &  \\ 
  & \mid {\sf REM(x, y) \mid REM\_N(X, Y, n)} & \\ 
  & \mid {\sf OR(x, y)  \mid OR\_N(X, Y, n)} &  \\ 
  & \mid {\sf AND(x, y) \mid AND\_N(X, Y, n)} &  \\ 
  & \mid {\sf MUX(x, y, c) \mid MUX\_N(X, Y, c, n)} &  \\ 
  \end{array}
\end{array}
\]
%\vspace{-0.2in}
\caption{Target MPC syntax: $s$ is a straight-line sequence of statements. 
\x, \y, and {\sf i} are variables, {\A}, \X, and \Y are arrays. $p$ is what we call an MPC primitive. 
\n is the length of the arrays passed to parallel functions. This means that
ADD, SUB, MUL, CMP, XOR, SHL, SHR, REM, OR, AND, and MUX are functions on scalar values, 
while ADD_N, SUB_N, MUL_N, CMP_N, XOR_N, SHL_N, SHR_N, REM_N, OR_N, AND_N, and MUX_N are parallel functions on arrays.
Our analysis takes a high-level C-like program and outputs a (potentially vectorized) in this low-level target language.
%\ana{Change font for x and y, as in the other syntax figure.}\lindsey{fixed!}
%\ana{I'm having hard time remembering what we had in mind with this figure... This was the target MPC code, right?}
%\ana{If yes, then remove the for loop. There is no for loop in MPC code, we just unrol.}
%\ana{TODO, ANA: I think here we might have to introduce the parallel MUX, AND, etc.,} \lindsey{fixed!}
}
\label{fig:muximpsyntax}
\end{figure}
