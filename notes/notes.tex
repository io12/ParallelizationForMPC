\documentclass{article}

\begin{document}

\section{Examples of SSA with Arrays}

Start with a few examples of "SSA with Arrays". In the beginning we'll start with manually transforming our code into "SSA with Arrays". We will eventually augment with some kind of automatic transformation. By "SSA with Arrays" I mean just the standard treatment of arrays in the classical SSA paper by Cytron et al. not the "Array SSA" form by Knobe and Sarkar that we were looking at some time ago. For example:

\begin{verbatim}
for (int i=1; i<=N; i++) {
  A[i] = f1(B[i]);
  B[i] = f2(A[i], D[i-1]);
  C[i] = f3(A[i], D[i-1]);
  D[i] = f4(B[i], C[i]);
}
\end{verbatim}

becomes

\begin{verbatim}

// initialize A, B, C, and D

for (int i=1; i<=N; i++) {
  // This is the phi node that SSA would insert
  A1 = phi(A, A2); B1 = phi(B, B2); C1 = phi(C, C2); D1 = phi(D, D2); 

  // This is a "fake" arraycopy as SSA would do
  // In standard SSA these 2 lines will be expressed by
  // A2 = Update(A1,i,f1(B1[i]));
  // I think the 2 lines are clearer and maybe easier to analyze
  A2 = arraycpy(A1); 
  A2[i] = f1(B1[i]); 
  
  B2 = arraycpy(B1);
  B2[i] = f2(A2[i], D1[i-1]);
  
  C2 = arraycpy(C1);
  C2[i] = f3(A2[i], D1[i-1]);
  
  D2 = arraycpy(D1);
  D2[i] = f4(B2[i], C2[i]);
}
\end{verbatim}

Another example, with if-then-else:

\begin{verbatim}
for (int i=1; i<=N; i++) {
  if (C[i]) then
    X[i] = ...
  else 
    X[i] = ...   
}
\end{verbatim}

becomes

\begin{verbatim}
for (int i=1; i<=N; i++) {
  X1 = phi(X,X4); 
  
  if (C[i]) then {
    X2 = arraycpy(X1);
    X2[i] = ...
  }  
  else {
    X3 = arraycpy(X2);
    X3[i] = ...
  }     
  X4 = phi(X2,X3);
}
\end{verbatim}
 
You can think of other examples too. Look at the ArraySSA paper for more examples.

\section{Implementation} 

Start with Soot's Shimple. Ishaq's OPA repo is based on Shimple, so you can start off from Ishaq's code but in the beginning build on Shimple only. 
Shimple is Soot's SSA but according to Ishaq it's buggy, and it does not have support for arrays. So my suggestion is to write the code with those
\texttt{phi} and \texttt{arraycpy} transforms, i.e., in the beginning we'll just manually translate into SSA with arrays. Run on several examples just to see what Shimple does.

\section{Array Def-Use and the Dependence Graph}

Next, implement def-use. Scalar def-use is trivial in SSA, there is probably already API to get the def of a given use. We have to implement array def-use:
\begin{itemize}

\item Let $A_j[f(i)] = ...$ be a definition at some node $d$, and let $ ... = A_k[f'(i)]$ be a use at some node $u$. There is a dependence edge in our graph (i.e., a def-use chain) from $d$ to $u$ iff $A_j[f(i)]$ reaches $A_k[f'(i)]$ and $f(i) = f'(i)$. Here ``reaches'' is in the standard sense of reaching definitions: there is at least one path from $d$ to $u$ without a redefinition of $A_j[f(i)]$. For example, there is a def-use chain from node $A2[i] = f1(B1[i])$ to node $B2[i] = f2(A2[i], D1[i-1])$ in our first example. In most cases the indices $j$ and $k$ will be the same, but that is not necessarily so. 

\item Let $A_j[f(i)] = ...$ be a definition at some node $d$, and let $ ... = A_1[f'(i)]$. Fix an index $j$. If there is some $j' < j$ such that $f'(j') = f(j)$ (if there is a $j'$ then it is unique), and $A_j[f(i)]$ is such that it reaches the loop body, then there is a \emph{loop-carried} dependence edge from $d$ to $u$. We'll annotate the loop-carried dependence edge with the difference $d = j - j'$; this indicates that node $u$ depends on the computation at node $d$ that happened $d$ iterations earlier.

In our first example, there is a loop-carried dependence edge from $D2[i] = f4(B2[i], C2[i])$ to $B2[i] = f2(A2[i], D1[i-1])$. Here $f(i) = i-1$ and $f'(i) = i$, which is the most common case. So the $j'$ is $j-1$, and the difference is $j - (j - 1) = 1$. 

\end{itemize}

In order for the above to work we will make the following assumptions about array accesses:

\begin{itemize}

\item Let $f(i,x)$ be a "index function", i.e., function we use to access array elements. Here $i$ is the induction variable, and $x$ is a vector of other variables and constants. (Most of the time this is just $i$ but I'd like to make things more general with an eye on extending with nested loops.) The index functions are such that $x$ is a constant throughout the duration of the entire loop. I.e., $f(i,x)$ depends only on $i$. 

\item We have ``disjointness of writes''. For each pair of writes $A_j[f(i)] = ... $ and $A_k[f'(i')] = ... $ where $i$ and $i'$ denote values of the induction variable, if $i \neq i'$ then $f(i) \neq f'(i')$. In other words, we cannot have two distinct iterations modifying the same array location.

\end{itemize}

\section{Find SCCs}

The above will construct the graph (nodes are statements in the loop body) and edges are the def-use dependences, including within-iteration dependences and loop-carried dependences. From here we can construct those SCCs and form a DAG of SCCs, where each SCC comes with a delay $d$. We make use of the \emph{constant-rate assumption} and we'll have to take the $d$'s of a bunch of loops to verify that indeed the constant-rate assumption holds. In practice $d$ is either 1 or infinity, i.e., we either have a sequential schedule for the instruction or the instruction can be vectorized. 

\end{document}
