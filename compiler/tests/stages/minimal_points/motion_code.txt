template <encrypto::motion::MpcProtocol Protocol>
std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(
    encrypto::motion::PartyPointer &party,
    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,
    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,
    std::uint32_t _MPC_PLAINTEXT_N_0
) {
    // Shared variable declarations
    encrypto::motion::SecureUnsignedInteger _11_2;
    std::vector<encrypto::motion::SecureUnsignedInteger> _12_2;
    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _13_1;
    encrypto::motion::ShareWrapper _3_3;
    encrypto::motion::ShareWrapper _4_3;
    encrypto::motion::ShareWrapper _5_3;
    encrypto::motion::ShareWrapper _6_2;
    encrypto::motion::SecureUnsignedInteger _8_2;
    std::vector<encrypto::motion::SecureUnsignedInteger> _9_2;
    encrypto::motion::SecureUnsignedInteger N_0;
    encrypto::motion::ShareWrapper bx_2;
    encrypto::motion::ShareWrapper bx_3;
    encrypto::motion::ShareWrapper bx_4;
    encrypto::motion::SecureUnsignedInteger i_1;
    encrypto::motion::SecureUnsignedInteger j_1;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_X_1;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_X_2;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_X_3;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_X_4;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_Y_1;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_Y_2;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_Y_3;
    std::vector<encrypto::motion::SecureUnsignedInteger> min_Y_4;

    // Plaintext variable declarations
    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__13_1;
    bool _MPC_PLAINTEXT_bx_2;
    std::uint32_t _MPC_PLAINTEXT_i_1;
    std::uint32_t _MPC_PLAINTEXT_j_1;
    std::vector<std::uint32_t> _MPC_PLAINTEXT_min_X_1;
    std::vector<std::uint32_t> _MPC_PLAINTEXT_min_Y_1;

    // Constant initializations
    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<Protocol>(encrypto::motion::BitVector(1, false), 0);

    // Plaintext parameter assignments
    N_0 = party->In<Protocol>(encrypto::motion::ToInput(_MPC_PLAINTEXT_N_0), 0);

    // Function body
    min_X_1 = {};
    _MPC_PLAINTEXT_min_X_1 = {};
    min_Y_1 = {};
    _MPC_PLAINTEXT_min_Y_1 = {};

    // Initialize phi values
    min_X_2 = min_X_1;
    min_Y_2 = min_Y_1;
    for (_MPC_PLAINTEXT_i_1 = std::uint32_t(0); _MPC_PLAINTEXT_i_1 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT_i_1++) {
        i_1 = party->In<Protocol>(encrypto::motion::ToInput(_MPC_PLAINTEXT_i_1), 0);
        bx_2 = _MPC_CONSTANT_false;
        _MPC_PLAINTEXT_bx_2 = false;

        // Initialize phi values
        bx_3 = bx_2;
        for (_MPC_PLAINTEXT_j_1 = std::uint32_t(0); _MPC_PLAINTEXT_j_1 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT_j_1++) {
            j_1 = party->In<Protocol>(encrypto::motion::ToInput(_MPC_PLAINTEXT_j_1), 0);
            _3_3 = (X_coords_0[_MPC_PLAINTEXT_i_1] > X_coords_0[_MPC_PLAINTEXT_j_1]);
            _4_3 = (Y_coords_0[_MPC_PLAINTEXT_i_1] > Y_coords_0[_MPC_PLAINTEXT_j_1]);
            _5_3 = (encrypto::motion::ShareWrapper(_3_3.Get()) & encrypto::motion::ShareWrapper(_4_3.Get()));
            bx_4 = (encrypto::motion::ShareWrapper(bx_3.Get()) | encrypto::motion::ShareWrapper(_5_3.Get()));

            // Update phi values
            bx_3 = bx_4;
        }

        _6_2 = (~bx_3);
        _8_2 = X_coords_0[_MPC_PLAINTEXT_i_1];
        _9_2 = {_8_2};
        min_X_3 = (min_X_2 + _9_2);
        _11_2 = Y_coords_0[_MPC_PLAINTEXT_i_1];
        _12_2 = {_11_2};
        min_Y_3 = (min_Y_2 + _12_2);
        min_X_4 = _6_2.Mux(min_X_3.Get(), min_X_2.Get());
        min_Y_4 = _6_2.Mux(min_Y_3.Get(), min_Y_2.Get());

        // Update phi values
        min_X_2 = min_X_4;
        min_Y_2 = min_Y_4;
    }

    _13_1 = std::make_tuple(min_X_2, min_Y_2);

    return _13_1;
}
